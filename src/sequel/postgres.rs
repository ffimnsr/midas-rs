use anyhow::Context;
use postgres::{Client, NoTls};
use url::Url;
use indoc::{indoc, formatdoc};

use super::{AnyhowResult, Driver as SequelDriver, VecSerial};

pub struct Postgres {
    client: Client,
    database_name: String,
}

impl Postgres {
    pub fn new(database_url: &str) -> AnyhowResult<Self> {
        let url = Url::parse(database_url)?;
        let database_name = url
            .path_segments()
            .and_then(|s| s.last())
            .context("Database name not found")?;

        log::debug!("Connecting to database: {}", database_name);
        let client = Client::connect(url.as_str(), NoTls)?;
        let mut db = Postgres { client, database_name: database_name.into() };
        db.ensure_midas_schema()?;
        Ok(db)
    }
}

impl SequelDriver for Postgres {
    fn ensure_midas_schema(&mut self) -> AnyhowResult<()> {
        let payload = indoc! {"
        do
        $$
        begin
        create schema if not exists public;
        create schema if not exists midas;
        grant all on schema public to public;
        grant all on schema midas to public;
        create table if not exists midas.__schema_migrations (
            id bigint generated by default as identity primary key,
            migration bigint
        );
        end
        $$;
        "};
        self.client.execute(payload, &[])?;
        Ok(())
    }

    fn drop_migration_table(&mut self) -> AnyhowResult<()> {
        let payload = "drop table midas.__schema_migrations";
        self.client.execute(payload, &[])?;
        Ok(())
    }

    fn drop_database_schemas(&mut self) -> AnyhowResult<()> {
        let payload = indoc! {"
        do $$ declare
            r record;
        begin
            for r in (select nspname from pg_namespace where oid > 16384) loop
                execute 'drop schema if exists ' || quote_ident(r.nspname) || ' cascade';
                execute 'create schema ' || quote_ident(r.nspname);
            end loop;
        end $$;
        "};
        self.client.execute(payload, &[])?;
        Ok(())
    }

    fn count_migrations(&mut self) -> AnyhowResult<i64> {
        log::trace!("Retrieving migrations count");
        let payload =
            "select count(*) as count from midas.__schema_migrations";
        let row = self.client.query_one(payload, &[])?;
        let result = row.get::<_, i64>(0);
        Ok(result)
    }

    fn get_completed_migrations(&mut self) -> AnyhowResult<VecSerial> {
        log::trace!("Retrieving all completed migrations");
        let payload =
            "select migration from midas.__schema_migrations order by id asc";
        let it = self.client.query(payload, &[])?;
        let result = it.iter().map(|r| r.get("migration")).collect::<_>();
        Ok(result)
    }

    fn get_last_completed_migration(&mut self) -> AnyhowResult<i64> {
        log::trace!("Checking and retrieving the last migration stored on migrations table");
        let payload =
            "select migration from midas.__schema_migrations order by id desc limit 1";
        let result = self.client.query(payload, &[])?;
        Ok(result.get(0).map_or(-1, |r| r.get(0)))
    }

    fn add_completed_migration(
        &mut self,
        migration_number: i64,
    ) -> AnyhowResult<()> {
        log::trace!("Adding migration to migrations table");
        let payload =
            "insert into midas.__schema_migrations (migration) values ($1)";
        self.client.execute(payload, &[&migration_number])?;
        Ok(())
    }

    fn delete_completed_migration(
        &mut self,
        migration_number: i64,
    ) -> AnyhowResult<()> {
        log::trace!("Removing a migration in the migrations table");
        let payload =
            "delete from midas.__schema_migrations where migration = $1";
        self.client.execute(payload, &[&migration_number])?;
        Ok(())
    }

    fn delete_last_completed_migration(&mut self) -> AnyhowResult<()> {
        let payload =
            "delete from midas.__schema_migrations where id=(select max(id) from midas.__schema_migrations);";
        self.client.execute(payload, &[])?;
        Ok(())
    }

    fn migrate(&mut self, query: &str) -> AnyhowResult<()> {
        self.client.simple_query(query)?;
        Ok(())
    }

    fn get_db_table_state(&mut self, table_name: &str) -> AnyhowResult<()> {
        let database_name: &str = &self.database_name;
        let payload = formatdoc! {"
            select
                ordinal_position,
                column_name,
                column_default,
                udt_schema,
                udt_name,
                is_nullable
            from information_schema.columns
            where table_catalog = '{database_name}'
            and table_name = '{table_name}';
        "};
        let it = self.client.query(&payload, &[])?;
        for row in it {
            let ordinal_position: i32 = row.get("ordinal_position");
            let column_name: String = row.get("column_name");
            let column_default: Option<String> = row.get("column_default");
            let udt_schema: String = row.get("udt_schema");
            let udt_name: String = row.get("udt_name");
            let is_nullable: String = row.get("is_nullable");
            log::info!(
                "ordinal_position: {}, column_name: {}, column_default: {:?}, udt_schema: {}, udt_name: {}, is_nullable: {}",
                ordinal_position,
                column_name,
                column_default,
                udt_schema,
                udt_name,
                is_nullable,
            );
        }
        Ok(())
    }

    fn db_name(&self) -> &str {
        &self.database_name
    }
}
