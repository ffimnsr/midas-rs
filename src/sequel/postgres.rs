
use log::trace;
use postgres::{Client, NoTls};

use super::{Driver as SequelDriver, Error, VecSerial};

pub struct Postgres {
    client: Client,
}

impl Postgres {
    pub fn new(database_url: &str) -> Result<Self, Error> {
        let client = Client::connect(database_url, NoTls)?;
        let mut db = Postgres { client };
        db.ensure_migration_schema_exists()?;
        db.ensure_migration_table_exists()?;
        Ok(db)
    }
}

impl SequelDriver for Postgres {
    fn ensure_migration_schema_exists(&mut self) -> Result<(), Error> {
        self.client.execute("create schema if not exists public", &[])?;
        self.client.execute("grant all on schema public to public", &[])?;
        Ok(())
    }

    fn ensure_migration_table_exists(&mut self) -> Result<(), Error> {
        let payload = r#"
            create table if not exists public.__schema_migrations (
                id bigint generated by default as identity primary key,
                migration bigint
            )
        "#;
        self.client.execute(payload, &[])?;
        Ok(())
    }

    fn drop_migration_table(&mut self) -> Result<(), Error> {
        let payload = "drop table public.__schema_migrations";
        self.client.execute(payload, &[])?;
        Ok(())
    }

    fn drop_database(&mut self, db_name: &str) -> Result<(), Error> {
        let payload = format! {"drop database if exists {db_name}"};
        self.client.execute(&payload, &[])?;

        let payload = format! {"create database {db_name}"};
        self.client.execute(&payload, &[])?;
        Ok(())
    }

    fn count_migrations(&mut self) -> Result<i64, Error> {
        trace!("Retrieving migrations count");
        let payload =
            "select count(*) as count from public.__schema_migrations";
        let row = self.client.query_one(payload, &[])?;
        let result = row.get::<_, i64>(0);
        Ok(result)
    }

    fn get_completed_migrations(&mut self) -> Result<VecSerial, Error> {
        trace!("Retrieving all completed migrations");
        let payload =
            "select migration from public.__schema_migrations order by id asc";
        let it = self.client.query(payload, &[])?;
        let result =
            it.iter().map(|r| r.get("migration")).collect::<_>();
        Ok(result)
    }

    fn get_last_completed_migration(&mut self) -> Result<i64, Error> {
        trace!("Checking and retrieving the last migration stored on migrations table");
        let payload =
            "select migration from public.__schema_migrations order by id desc limit 1";
        let result = self.client.query(payload, &[])?;

        if result.is_empty() {
            Ok(-1)
        } else {
            Ok(result[0].get(0))
        }
    }

    fn add_completed_migration(
        &mut self,
        migration_number: i64,
    ) -> Result<(), Error> {
        trace!("Adding migration to migrations table");
        let payload =
            "insert into public.__schema_migrations (migration) values ($1)";
        self.client.execute(payload, &[&migration_number])?;
        Ok(())
    }

    fn delete_completed_migration(
        &mut self,
        migration_number: i64,
    ) -> Result<(), Error> {
        trace!("Removing a migration in the migrations table");
        let payload =
            "delete from public.__schema_migrations where migration = $1";
        self.client.execute(payload, &[&migration_number])?;
        Ok(())
    }

    fn delete_last_completed_migration(&mut self) -> Result<(), Error> {
        let payload =
            "delete from public.__schema_migrations where id=(select max(id) from __schema_migrations);";
        self.client.execute(payload, &[])?;
        Ok(())
    }

    fn migrate(&mut self, query: &str) -> Result<(), Error> {
        self.client.simple_query(query)?;
        Ok(())
    }
}
